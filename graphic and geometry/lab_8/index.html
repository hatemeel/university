<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"
    />
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />

    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        user-select: none;
      }

      .container-fluid {
        width: 100%;
        height: 100%;
        display: flex;
        padding-right: 0;
      }

      .work-area {
        display: flex;
        flex: auto;
        height: 100%;
        padding: 15px;
        padding-bottom: 0;
      }

      .canvas-container {
        flex: auto;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        border: 1px solid black;
      }

      .mode-handlers {
        display: flex;
        flex-direction: column;
      }

      .mode-handlers .btn {
        margin-top: 15px;
      }

      .mode-handler {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 50px;
        height: 50px;
        font-size: 19px;
      }

      .mode-handler i {
        pointer-events: none;
      }

      .mode-handler.active {
        color: #2de657 !important;
      }

      .line-icon {
        transform: rotate(135deg) scaleX(1.5);
      }

      .info-panel {
        display: flex;
        padding: 5px;
        padding-right: 15px;
        align-self: flex-end;
      }

      .info-panel > div {
        margin-left: 20px;
      }

      .bold {
        font-weight: 600;
      }
    </style>
  </head>

  <body>
    <div class="container-fluid">
      <div class="mode-handlers">
        <div
          class="btn btn-secondary mode-handler"
          data-mode="cursor"
          title="cursor"
          onclick="toggleMode(event)"
        >
          <i class="fas fa-mouse-pointer"></i>
        </div>
        <div
          class="btn btn-secondary mode-handler active"
          data-mode="line"
          title="line"
          onclick="toggleMode(event)"
        >
          <i class="material-icons line-icon">remove</i>
        </div>
        <div
          class="btn btn-secondary mode-handler"
          data-mode="circle"
          title="circle"
          onclick="toggleMode(event)"
        >
          <i class="far fa-circle"></i>
        </div>
        <div
          class="btn btn-secondary mode-handler"
          data-mode="square"
          title="square"
          onclick="toggleMode(event)"
        >
          <i class="far fa-square"></i>
        </div>

        <input
          type="color"
          class="btn btn-secondary p-1 mode-handler mt-auto"
          title="pick color"
          oninput="setCurrentColor(event)"
        />

        <div class="btn btn-danger btn-block mt-2" onclick="stop()">
          <i class="fas fa-ban no-events"></i>
        </div>
      </div>

      <div class="work-area">
        <div class="canvas-container">
          <canvas
            onmousewheel="scrollCanvas(event); zoomCanvas(event)"
            onmousedown="startFigure(event)"
            onmousemove="drawFigure(event); showMousePos(event)"
            onmouseup="finishFigure(event)"
          ></canvas>
        </div>
      </div>
    </div>

    <div class="info-panel">
      <div class="info-scroll">
        Scroll: <span class="text-primary bold">X:0 Y:0</span>
      </div>
      <div class="info-mode">
        Mode: <span class="text-primary bold">line</span>
      </div>
      <div class="info-zoom">
        Zoom: <span class="text-primary bold">x1.0</span>
      </div>
    </div>

    <script>
      const container = document.querySelector('.canvas-container');
      const canvas = document.querySelector('canvas');
      const ctx = canvas.getContext('2d');
      CanvasRenderingContext2D.prototype.clear = function () {
        this.clearRect(0, 0, this.canvas.width, this.canvas.height);
      };
      CanvasRenderingContext2D.prototype.refresh = function () {
        this.strokeStyle = 'black';
        this.fillStyle = 'black';
        this.textAlign = 'left';
        this.textBaseline = 'alphabetic';
        this.lineWidth = 1;
      };

      let w = container.clientWidth;
      let h = container.clientHeight;

      canvas.width = w;
      canvas.height = h;

      let currentColor = '#000000';

      class Drawer {
        animate = true;

        // modes [cursor, line, ...]
        mode = 'line';
        active = false;

        scale = 1;
        moveX = 0;
        moveY = 0;
        scrollX = -Math.round(w / 2);
        scrollY = -Math.round(h / 2);

        figures = [];
        metrix;

        p;

        constructor(metrix, figures = []) {
          this.metrix = metrix;
          this.figures = figures;
        }

        draw() {
          const scaleCorrectionX =
            (this.scrollX + Math.round(w / 2)) * this.scale -
            (this.scrollX + Math.round(w / 2));

          const scaleCorrectionY =
            (this.scrollY + Math.round(h / 2)) * this.scale -
            (this.scrollY + Math.round(h / 2));

          const params = {
            scale: this.scale,
            moveX: this.moveX,
            moveY: this.moveY,
            scrollX: this.scrollX + scaleCorrectionX,
            scrollY: this.scrollY + scaleCorrectionY,
          };

          this.p = params;

          info(
            'scroll',
            `X:${(this.scrollX + Math.round(w / 2)).toFixed(1)}
      			Y:${(this.scrollY + Math.round(h / 2)).toFixed(1)}`
          );

          this.figures
            .sort(
              (a, b) =>
                new Date(a.lastUsed).getTime() - new Date(b.lastUsed).getTime()
            )
            .map((fig) => {
              if (fig.update) {
                fig.update(params);
              }
              fig.draw();
            });

          this.metrix.update(params);
          this.metrix.draw();
        }
      }

      class Metrix {
        startX;
        endX;
        startY;
        endY;

        mousePosX;
        mousePosY;

        scale;

        constructor() {
          this.update(0, 0);
        }

        update({ scrollX, scrollY, scale }) {
          this.scale = scale;

          this.startX = Math.round(scrollX / this.scale);
          this.endX = w / this.scale + this.startX;
          this.startY = Math.round(scrollY / this.scale);
          this.endY = h / this.scale + this.startY;
        }

        draw() {
          // lines
          ctx.beginPath();
          ctx.moveTo(5, 5);
          ctx.lineTo(w - 5, 5);
          ctx.moveTo(5, 5);
          ctx.lineTo(5, h - 5);
          ctx.strokeStyle = 'gray';
          ctx.closePath();
          ctx.stroke();
          ctx.refresh();

          let scaleCorrection = 50;

          if (this.scale <= 0.3) {
            scaleCorrection = 500;
          } else if (this.scale <= 0.5) {
            scaleCorrection = 100;
          } else if (this.scale >= 8) {
            scaleCorrection = 5;
          } else if (this.scale >= 5) {
            scaleCorrection = 10;
          } else if (this.scale >= 2) {
            scaleCorrection = 25;
          }

          // numbers
          ctx.font = '10px';

          ctx.textAlign = 'center';
          for (let i = this.startX; i < this.endX; i += 1) {
            if (i - this.startX > 5 && i % (scaleCorrection / 2) === 0) {
              ctx.beginPath();
              ctx.moveTo((i - this.startX) * this.scale, 2);
              ctx.lineTo((i - this.startX) * this.scale, 8);
              ctx.closePath();
              ctx.stroke();

              if (i % scaleCorrection === 0 && i - this.startX > 20) {
                ctx.fillText(i, (i - this.startX) * this.scale, 19);
              }
            }
          }

          ctx.textAlign = 'left';
          ctx.textBaseline = 'middle';
          for (let i = this.startY; i < this.endY; i += 1) {
            if (i - this.startY > 5 && i % (scaleCorrection / 2) === 0) {
              ctx.beginPath();
              ctx.moveTo(2, (i - this.startY) * this.scale);
              ctx.lineTo(8, (i - this.startY) * this.scale);
              ctx.closePath();
              ctx.stroke();

              if (i % scaleCorrection === 0 && i - this.startY > 20) {
                ctx.fillText(i, 11, (i - this.startY) * this.scale);
              }
            }
          }

          ctx.refresh();

          ctx.strokeStyle = 'red';
          ctx.beginPath();
          ctx.moveTo(this.mousePosX, 0);
          ctx.lineTo(this.mousePosX, 10);
          ctx.moveTo(0, this.mousePosY);
          ctx.lineTo(10, this.mousePosY);
          ctx.closePath();
          ctx.stroke();

          ctx.refresh();
        }
      }

      class Line {
        x1;
        x2;
        y1;
        y2;

        offsetX;
        offsetY;

        width;

        scale;

        lastUsed;

        color;

        constructor() {
          this.width = 2;
        }

        refresh() {
          this.x1 = undefined;
          this.x2 = undefined;
          this.y1 = undefined;
          this.y2 = undefined;
        }

        update({ scrollX, scrollY, scale }) {
          this.width = 2 * scale;
          this.scale = scale;
          this.offsetX = Math.round(scrollX / this.scale);
          this.offsetY = Math.round(scrollY / this.scale);
        }

        draw() {
          ctx.beginPath();
          ctx.moveTo(
            (this.x1 - this.offsetX) * this.scale,
            (this.y1 - this.offsetY) * this.scale
          );
          ctx.lineTo(
            (this.x2 - this.offsetX) * this.scale,
            (this.y2 - this.offsetY) * this.scale
          );
          ctx.lineWidth = this.width;
          ctx.strokeStyle = this.color;
          ctx.closePath();
          ctx.stroke();
          ctx.refresh();
        }
      }

      class Circle {
        x;
        y;
        radiusEndX;
        radiusEndY;
        radius;

        offsetX;
        offsetY;

        width;

        scale;

        lastUsed;

        color;

        refresh() {
          this.x = undefined;
          this.y = undefined;
          this.radiusEndX = undefined;
          this.radiusEndY = undefined;
          this.radius = undefined;
        }

        update({ scrollX, scrollY, scale }) {
          this.width = 2 * scale;
          this.scale = scale;
          this.offsetX = Math.round(scrollX / this.scale);
          this.offsetY = Math.round(scrollY / this.scale);
          this.radius =
            getLength(
              point(this.x, this.y),
              point(this.radiusEndX, this.radiusEndY)
            ) * this.scale;
        }

        draw() {
          ctx.beginPath();
          ctx.arc(
            (this.x - this.offsetX) * this.scale,
            (this.y - this.offsetY) * this.scale,
            this.radius,
            0,
            Math.PI * 2
          );
          ctx.lineWidth = this.width;
          ctx.strokeStyle = this.color;
          ctx.closePath();
          ctx.stroke();
          ctx.refresh();
        }
      }

      class Square {
        x1;
        y1;
        x2;
        y2;

        sizeX;
        sizeY;

        offsetX;
        offsetY;

        width;

        scale;

        lastUsed;

        color;

        refresh() {
          this.x1 = undefined;
          this.y1 = undefined;
          this.x2 = undefined;
          this.y2 = undefined;
          this.sizeX = undefined;
          this.sizeY = undefined;
        }

        update({ scrollX, scrollY, scale }) {
          this.width = 2 * scale;
          this.scale = scale;
          this.offsetX = Math.round(scrollX / this.scale);
          this.offsetY = Math.round(scrollY / this.scale);

          this.sizeX =
            (this.x2 - this.offsetX) * this.scale -
            (this.x1 - this.offsetX) * this.scale;

          this.sizeY =
            (this.y2 - this.offsetY) * this.scale -
            (this.y1 - this.offsetY) * this.scale;
        }

        draw() {
          ctx.beginPath();
          ctx.rect(
            (this.x1 - this.offsetX) * this.scale,
            (this.y1 - this.offsetY) * this.scale,
            this.sizeX,
            this.sizeY
          );
          ctx.lineWidth = this.width;
          ctx.strokeStyle = this.color;
          ctx.closePath();
          ctx.stroke();
          ctx.refresh();
        }
      }

      const metrix = new Metrix();
      const line = new Line();
      const circle = new Circle();
      const square = new Square();
      const drawer = new Drawer(metrix, [line, circle, square]);
      function animate() {
        if (drawer.animate) {
          ctx.clear();
          requestAnimationFrame(animate);

          drawer.draw();
        }
      }
      animate();

      // FIGURE FUNCTIONS ====
      function startFigure(event) {
        drawer.active = true;

        if (drawer.mode === 'line') {
          line.refresh();
          line.x1 = (x(event.x) + drawer.p.scrollX) / drawer.scale;
          line.y1 = (y(event.y) + drawer.p.scrollY) / drawer.scale;
          line.lastUsed = new Date();
          line.color = currentColor;
        } else if (drawer.mode === 'circle') {
          circle.refresh();
          circle.x = (x(event.x) + drawer.p.scrollX) / drawer.scale;
          circle.y = (y(event.y) + drawer.p.scrollY) / drawer.scale;
          circle.lastUsed = new Date();
          circle.color = currentColor;
        } else if (drawer.mode === 'square') {
          square.refresh();
          square.x1 = (x(event.x) + drawer.p.scrollX) / drawer.scale;
          square.y1 = (y(event.y) + drawer.p.scrollY) / drawer.scale;
          square.lastUsed = new Date();
          square.color = currentColor;
        }
      }

      function drawFigure(event) {
        if (drawer.active) {
          if (drawer.mode === 'line') {
            line.x2 = (x(event.x) + drawer.p.scrollX) / drawer.scale;
            line.y2 = (y(event.y) + drawer.p.scrollY) / drawer.scale;
          } else if (drawer.mode === 'circle') {
            circle.radiusEndX = (x(event.x) + drawer.p.scrollX) / drawer.scale;
            circle.radiusEndY = (y(event.y) + drawer.p.scrollY) / drawer.scale;
          } else if (drawer.mode === 'square') {
            square.x2 = (x(event.x) + drawer.p.scrollX) / drawer.scale;
            square.y2 = (y(event.y) + drawer.p.scrollY) / drawer.scale;
          }
        }
      }

      function finishFigure(event) {
        drawer.active = false;
      }

      // MAIN FUNCTIONS ====
      // mode handlers
      function toggleMode(event) {
        document.querySelectorAll('.mode-handler').forEach((el) => {
          el.classList.remove('active');
        });

        event.target.classList.add('active');
        drawer.mode = event.target.dataset.mode;

        info('mode', drawer.mode);
      }

      // SCROLL
      function scrollCanvas(event) {
        if (!event.ctrlKey) {
          let scrollDelta = 5 / (drawer.scale / 2);

          if (event.shiftKey) {
            // scroll x

            if (event.wheelDelta > 0) {
              drawer.scrollX -= scrollDelta;
            } else {
              drawer.scrollX += scrollDelta;
            }
          } else {
            // scroll y

            if (event.wheelDelta > 0) {
              drawer.scrollY -= scrollDelta;
            } else {
              drawer.scrollY += scrollDelta;
            }
          }
        }
      }

      // ZOOM
      function zoomCanvas(event) {
        if (event.ctrlKey) {
          event.preventDefault();

          if (event.wheelDelta > 0) {
            if (drawer.scale < 10) {
              drawer.scale += 0.1;
              drawer.scale = drawer.scale.toFixed(1) * 1;
            }
          } else {
            if (drawer.scale > 0.1) {
              drawer.scale -= 0.1;
              drawer.scale = drawer.scale.toFixed(1) * 1;
            }
          }

          info('zoom', `x${drawer.scale.toFixed(1)}`);
        }
      }

      function showMousePos(event) {
        metrix.mousePosX = x(event.x);
        metrix.mousePosY = y(event.y);
      }

      function setCurrentColor(event) {
        currentColor = event.target.value;
      }

      // stop animation
      function stop() {
        console.log('Animation stoped!');
        drawer.animate = false;
      }

      // HELPERS ====
      function getLength(a, b) {
        return Math.pow(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2), 0.5);
      }

      function x(xVal) {
        return xVal - canvas.offsetLeft;
      }

      function y(yVal) {
        return yVal - canvas.offsetTop;
      }

      function point(xVal, yVal) {
        return { x: xVal, y: yVal };
      }

      function info(type, text) {
        document.querySelector(`.info-${type} span`).innerHTML = text;
      }
    </script>
  </body>
</html>
